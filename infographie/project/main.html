<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="utf-8" />
		<!--<link rel="stylesheet" href="css/stylesheet.css">-->
		<script src="../js/commonFunctions.js"></script>
		<script src="../js/gl-matrix-min.js"></script>
		<script src="../js/webglTools.js"></script>
		<!--<script src="planet.js"/>-->
		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec4 aColor;
		    uniform mat4 uMVMatrix;
		    uniform mat4 uPMatrix;
			uniform vec3 center;
			varying vec3 aCenter;
			varying vec4 vColor;
			varying vec3 vPosition;
			varying vec3 vLightpos;
			uniform int vmode;
			const vec3 lightpos = vec3(0.0, 0.0, 0.0);
		    void main(void) {
		        vColor = aColor;
				gl_PointSize = 4.0;
				if(vmode != 0) // billboards
				{
					vec4 a = uPMatrix * vec4(aVertexPosition - center, 1.0);
					vec4 c = uPMatrix * uMVMatrix * vec4(center, 1.0);
					gl_Position = c + a;
					vPosition = gl_Position.xyz;
					aCenter = c.xyz;
					vLightpos = (uPMatrix * uMVMatrix * vec4(lightpos, 1.0)).xyz;
				}
				else
				{
					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
					vPosition = aVertexPosition;
				}
			}
		</script>
		<script id="shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
				precision highp float;
			#endif
		    uniform mat4 uMVMatrix;
		    uniform mat4 uPMatrix;
			varying vec4 vColor;
			varying vec3 vPosition;
			uniform int fmode;
			uniform float radius;
			varying vec3 aCenter;
			varying vec3 vLightpos;
			const float amb = 0.5;
			const float spec = 0.5;
			const float diff = 0.5;
			const float alpha = 8.0;
			void main(void) {
				if(fmode == 1) // billboards
				{
					// vec3 lightPos = vec3(0.0, 0.0, 0.0);
					vec3 center = aCenter;
					float r = radius;
					float dist = distance(center.xy, vPosition.xy);
					if(dist <= r)
					{
						vec3 lightPos = vLightpos;
						float z = sqrt(r * r - dist * dist);
						vec3 N = normalize(vec3(vPosition.x - center.x, vPosition.y - center.y, z));
						vec3 L = normalize((center + N * r) - lightPos);
						// vec3 V = normalize((center + N * r) - /*???*/ vec3(0.0, 0.0, 1.0));
						vec3 V = normalize((center + N * r) - (uPMatrix * uMVMatrix * vec4(0.0, 0.0, 1.0, 1.0)).xyz);
						// vec3 V = normalize(vec3(0.0, 0.0, 1.0));
						vec3 R = normalize(reflect(-L, N));
						vec3 ambientColor = vColor.xyz * amb;
						vec3 diffuseColor = diff * vColor.xyz * (dot(L, N) - 0.5);
						vec3 specularColor = vec3(spec, spec, spec) * pow(max(dot(R, V), 0.0), alpha);
						gl_FragColor = vec4(ambientColor + diffuseColor + specularColor, 1.0);
						// radius < distance(center.xy, vPosition.xy) ? gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0) : 
						// gl_FragColor = vec4(vColor.xyz, step(dist, r));	
					}					
					
				}
				else if(fmode == 2) // sun
				{
					float r = radius;
					float dist = distance(aCenter.xy, vPosition.xy);
					gl_FragColor = vec4(vColor.xyz, step(dist, r));
				}
				else
				{
					gl_FragColor = vColor;
				}
			}
		</script>
		<script>
			function Planet(mass, speed, pos, radius, color, orbitFactor)
			{
				this.radius = radius;
				this.mass = mass;
				this.speed = speed;
				this.color = color;
				this.pos = pos;
				this.orbitFactor = orbitFactor;
			}
			Planet.prototype.update = function(mainBody)
			{
				var a = vec3.create(); // acceleration vector
				var d = vec3.create(); // direction vector
				vec3.subtract(d, mainBody.pos, this.pos);
				var dist = vec3.dist(mainBody.pos, this.pos);
				vec3.scale(a, d, mainBody.mass / (dist * dist * dist)); // dist ^ 3 for normalization
				
				vec3.add(this.speed, this.speed, a);
				var deltaPos = vec3.create();
				vec3.scale(deltaPos, this.speed, SPEED_FACTOR * deltaT);
				vec3.add(this.pos, this.pos, deltaPos);
				if(this.mass == earth.mass)
				{
					console.clear();
					console.log('pos',this.pos);
					console.log('speed',this.speed);
				}
			}
			Planet.prototype.draw = function()
			{
				vertices = [];
				indices = [];
				colors = [];
				
				var c = [this.pos[0] / VISUAL_FACTOR, this.pos[1] / VISUAL_FACTOR, this.pos[2] / VISUAL_FACTOR];
				var radius = this.radius;
				vertices.push(
					c[0] + radius,
					c[1] + radius,
					c[2]
				);
				vertices.push(
					c[0] - radius,
					c[1] + radius,
					c[2]
				);
				vertices.push(
					c[0] + radius,
					c[1] - radius,
					c[2]
				);
				vertices.push(
					c[0] - radius,
					c[1] - radius,
					c[2]
				);
				colors.push(this.color[0], this.color[1], this.color[2], 1.0);
				colors.push(this.color[0], this.color[1], this.color[2], 1.0);
				colors.push(this.color[0], this.color[1], this.color[2], 1.0);
				colors.push(this.color[0], this.color[1], this.color[2], 1.0);
				indices.push(0, 1, 2, 3);
				
				if(this.mass == sol.mass)
				{
					glContext.uniform1i(prg.fmode, 2);
					glContext.uniform1i(prg.vmode, 2);
				}
				else
				{
					glContext.uniform1i(prg.fmode, 1);
					glContext.uniform1i(prg.vmode, 1);
				}
					
				glContext.uniform1f(prg.radius, radius);
				glContext.uniform3f(prg.center, c[0], c[1], 0.0);
				
				vertexBuffer = getVertexBufferWithVertices(vertices);
				indexBuffer = getIndexBufferWithIndices(indices);
				colorBuffer = getVertexBufferWithVertices(colors);
				glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
				glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
				glContext.bindBuffer(glContext.ARRAY_BUFFER, colorBuffer);
				glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);
				glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
				glContext.drawElements(glContext.TRIANGLE_STRIP, indices.length, glContext.UNSIGNED_SHORT,0);
			}
			Planet.prototype.drawOrbit = function(mainBody)
			{
				vertices = [];
				indices = [];
				colors = [];
				
				vertices.push(this.pos[0] / VISUAL_FACTOR, this.pos[1] / VISUAL_FACTOR, this.pos[2] / VISUAL_FACTOR);
				indices.push(indices.length);
				colors.push(this.color[0], this.color[1], this.color[2], 1.0);
				
				var s = vec3.create();
				var p = vec3.create();
				vec3.copy(s, this.speed);
				vec3.copy(p, this.pos);
				for(var j = 0; j < 50; j++)
				{
					var a = vec3.create();
					var d = vec3.create(); // direction vector
					vec3.subtract(d, mainBody.pos, p);
					var dist = vec3.dist(mainBody.pos, p);
					vec3.scale(a, d, mainBody.mass / (dist * dist * dist)); // dist ^ 3 for normalization
					vec3.add(s, s, a);
					var deltaPos = vec3.create();
					vec3.scale(deltaPos, s, SPEED_FACTOR * this.orbitFactor * deltaT);
					vec3.add(p, p, deltaPos);
					
					vertices.push(p[0] / VISUAL_FACTOR, p[1] / VISUAL_FACTOR, p[2] / VISUAL_FACTOR);
					indices.push(indices.length);
					colors.push(this.color[0], this.color[1], this.color[2], 1.0);
				}
			
				vertexBuffer = getVertexBufferWithVertices(vertices);
				indexBuffer = getIndexBufferWithIndices(indices);
				colorBuffer = getVertexBufferWithVertices(colors);
				
				glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
				glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
				glContext.bindBuffer(glContext.ARRAY_BUFFER, colorBuffer);
				glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);
				glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
				glContext.drawElements(glContext.LINE_STRIP, indices.length, glContext.UNSIGNED_SHORT,0);
			}
			
			function System(mainBody, bodies)
			{
				this.mainBody = mainBody;
				this.bodies = bodies;
				this.mass = 0;
				for (i in bodies)
				{
					this.mass += bodies[i].mass;
				}
				this.speed = mainBody.speed;
				this.pos = mainBody.pos;
				this.orbitFactor = mainBody.orbitFactor;
			}
			System.prototype = Planet.prototype;
			System.prototype.constructor = System;
			System.prototype.updateBodies = function ()
			{
				for(i in this.bodies)
				{
					this.bodies[i].update(this.mainBody);
				}
			}
			System.prototype.drawBodies = function ()
			{
				this.mainBody.draw();
				for(i in this.bodies)
				{
					this.bodies[i].draw();
				}
			}
			System.prototype.drawOrbitBodies = function ()
			{
				for(i in this.bodies)
				{
					this.bodies[i].drawOrbit(this.mainBody);
				}
			}
			
			var DEBUG = false;
			var deltaT = 24 * 60 * 10;
			// var deltaT = 1;
			var ASTRONOMICAL_UNIT = 149597870700;
			var G = 6.67e-11;
			// var G = 1;
			var  VISUAL_FACTOR = 10;
			var MASS_FACTOR = 1e24 / ASTRONOMICAL_UNIT / ASTRONOMICAL_UNIT;
			var POSITION_FACTOR = 1e9 / ASTRONOMICAL_UNIT;
			var SPEED_FACTOR = 1e3 / ASTRONOMICAL_UNIT;
			function createPlanet(mass, speed, position, radius, color, orbitFactor)
			{
				var m = MASS_FACTOR * mass * G;
				var s = speed;
				var p = POSITION_FACTOR * position;
				return new Planet(m, [s, 0, 0], [0, p, 0], radius, color, orbitFactor);
			}

			var sol = createPlanet(1988500, 0, 0, 0.02, [1, 1, 1], 0);
			var mercury = createPlanet(0.3301, 38.86, 69.82, 0.01, [0.4, 0.4, 0.4], 10);
			var venus = createPlanet(4.8676, 34.79, 108.94, 0.015, [0.9, 0.9, 0.7], 20);
			var earth = createPlanet(5.9726, 29.29, 152.10, 0.02, [0.3, 0.5, 1.0], 30);
			var mars = createPlanet(0.64174, 21.97, 249.23, 0.01, [1.0, 0.0, 0.0], 40);
			var jupiter = createPlanet(1898.3, 12.44, 816.62, 0.08, [1.0, 0.5, 0.0], 80);
			var saturn = createPlanet(568.36, 9.09, 1514.50, 0.06, [1.0, 1.0, 0.7], 200);
			var uranus = createPlanet(86.816, 6.49, 3003.62, 0.05, [0.0, 1.0, 1.0], 550);
			var neptune = createPlanet(102.42, 5.37, 4545.67, 0.05, [0.0, 0.0, 1.0], 1100);
			
			// sources
			// http://nssdc.gsfc.nasa.gov/planetary/factsheet/mercuryfact.html
			// http://nssdc.gsfc.nasa.gov/planetary/factsheet/venusfact.html
			// http://nssdc.gsfc.nasa.gov/planetary/factsheet/earthfact.html
			// http://nssdc.gsfc.nasa.gov/planetary/factsheet/marsfact.html
			// http://nssdc.gsfc.nasa.gov/planetary/factsheet/jupiterfact.html
			// http://nssdc.gsfc.nasa.gov/planetary/factsheet/saturnfact.html
			// http://nssdc.gsfc.nasa.gov/planetary/factsheet/uranusfact.html
			// http://nssdc.gsfc.nasa.gov/planetary/factsheet/neptunefact.html
			// http://nssdc.gsfc.nasa.gov/planetary/factsheet/sunfact.html
			
			var planets = [mercury, venus, earth, mars, jupiter, saturn, uranus, neptune];
			var solarSystem = new System(sol, planets);
			
			var pause = true;
			var orbitBool = false;
			var translateZ = -2.0;
			var vertexBuffer = null;
			var indexBuffer = null;
			var colorBuffer = null;
			var indices = [];
			var vertices = [];
			var colors = [];
			var mvMatrix = mat4.create();
			var pMatrix = mat4.create();
			mat4.identity(mvMatrix);
			mat4.identity(pMatrix);
			window.onkeydown = function(e) {
				switch(e.keyCode){
					case 87:
						//w
						translateZ += 0.1;
						break;
					case 83:
						//s
						translateZ -= 0.1;
						break;
					default:
				}
			};
			function initShaderParameters(prg){
				prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
			    glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
			    prg.colorAttribute = glContext.getAttribLocation(prg, "aColor");
			    glContext.enableVertexAttribArray(prg.colorAttribute);
			    prg.pMatrixUniform = glContext.getUniformLocation(prg, 'uPMatrix');
			    prg.mvMatrixUniform = glContext.getUniformLocation(prg, 'uMVMatrix');
				prg.fmode = glContext.getUniformLocation(prg, 'fmode');
				prg.vmode = glContext.getUniformLocation(prg, 'vmode');
				prg.radius = glContext.getUniformLocation(prg, 'radius');
				prg.center = glContext.getUniformLocation(prg, 'center');
			}
			function initBuffers(){
			}
			function drawSystem()
			{
				solarSystem.drawBodies();
				glContext.uniform1i(prg.fmode, 0);
				glContext.uniform1i(prg.vmode, 0);
				if(orbitBool)solarSystem.drawOrbitBodies();
			}
			function drawScene(){
				glContext.clearColor(0.0, 0.0, 0.0, 1.0);
				// glContext.enable(glContext.DEPTH_TEST);
				
				glContext.blendFunc(glContext.SRC_ALPHA, glContext.ONE_MINUS_SRC_ALPHA);
				glContext.enable(glContext.BLEND);
				glContext.disable(glContext.DEPTH_TEST);
				
				glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
				
				glContext.viewport(0, 0, c_width, c_height);
				mat4.perspective(pMatrix, degToRad(60.0), c_width / c_height, 0.1, 10000.0);
				translationMat = mat4.create();
				mat4.identity(translationMat);
				mat4.translate(translationMat, translationMat, [0.0, 0.0, translateZ]);
				
				rotateModelViewMatrixUsingQuaternion();
				glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
				mvtMatrix = mat4.create();
				glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mat4.multiply(mvtMatrix, translationMat, mvMatrix));
				rotX = 0;
				rotY = 0;
				
				if (!pause) solarSystem.updateBodies();
				
				drawSystem();
			}
			function initWebGL(){
				glContext = getGLContext('webgl-canvas');
				initProgram();
				initBuffers();
				renderLoop();
			}
			function pauseBoolF()
			{
				pause = !pause;
			}
			function orbitBoolF()
			{
				orbitBool = !orbitBool;
			}
		</script>
	</head>
	<body onload="initWebGL()">
		<button onclick="pauseBoolF()">Play/pause</button>
		<button onclick="orbitBoolF()">Show/hide orbits</button>
		<br/>
		<canvas id="webgl-canvas" width="750" height="750">
			HTML5 is not supported
		</canvas>
	</body>
	<script src='../js/mouseMotionHandling.js'></script>
</html>
