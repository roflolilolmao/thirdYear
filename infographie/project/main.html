<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="utf-8" />
		<!--<link rel="stylesheet" href="css/stylesheet.css">-->
		<script src="../js/commonFunctions.js"></script>
		<script src="../js/gl-matrix-min.js"></script>
		<script src="../js/webglTools.js"></script>
		<!--<script src="planet.js"/>-->
		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec4 aColor;
		    uniform mat4 uMVMatrix;
		    uniform mat4 uPMatrix;
			uniform vec3 center;
			varying vec3 aCenter;
			varying vec4 vColor;
			varying vec3 vPosition;
			varying vec3 vLightpos;
			uniform int vmode;
			const vec3 lightpos = vec3(0.0, 0.0, 0.0);
		    void main(void) {
		        vColor = aColor;
				gl_PointSize = 4.0;
				if(vmode != 0)
				{
					vec4 a = uPMatrix * vec4(aVertexPosition - center, 1.0);
					vec4 c = uPMatrix * uMVMatrix * vec4(center, 1.0);
					gl_Position = c + a;
					vPosition = gl_Position.xyz;
					aCenter = c.xyz;
					vLightpos = (uPMatrix * uMVMatrix * vec4(lightpos, 1.0)).xyz;
				}
				else
				{
					gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
					vPosition = aVertexPosition;
				}
			}
		</script>
		<script id="shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
				precision highp float;
			#endif
			varying vec4 vColor;
			varying vec3 vPosition;
			uniform int mode;
			uniform float radius;
			varying vec3 aCenter;
			varying vec3 vLightpos;
			const float amb = 0.5;
			const float spec = 0.5;
			const float diff = 0.5;
			const float alpha = 8.0;
			void main(void) {
				if(mode == 1)
				{
					vec3 center = aCenter;
					vec3 lightPos = vLightpos;
					// vec3 lightPos = vec3(0.0, 0.0, 0.0);
					float r = radius;
					float dist = distance(center.xy, vPosition.xy);
					float z = sqrt(r * r - dist * dist);
					vec3 N = normalize(vec3(vPosition.x - center.x, vPosition.y - center.y, z));
					vec3 L = normalize(lightPos - (center + N * r));
					// vec3 V = normalize(vec3(0.0, 0.0, 1.0) - (center + N * r));
					vec3 V = normalize(vec3(0.0, 0.0, 1.0));
					// vec3 V = normalize((uPMatrix * uMVMatrix * vec4(vPosition, 1.0)).xyz);
					vec3 R = normalize(reflect(-L, N));
					vec3 ambientColor = vColor.xyz * amb;
					vec3 diffuseColor = diff * vColor.xyz * (dot(L, N) - 0.5);
					vec3 specularColor = vec3(spec, spec, spec) * pow(max(dot(R, V), 0.0), alpha);
					gl_FragColor = vec4(ambientColor + diffuseColor + specularColor, step(dist, r));
					// radius < distance(center.xy, vPosition.xy) ? gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0) : 
					// gl_FragColor = vec4(vColor.xyz, step(dist, r));						
					
				}
				else if(mode == 2)
				{
					float r = radius;
					float dist = distance(aCenter.xy, vPosition.xy);
					gl_FragColor = vec4(vColor.xyz, step(dist, r));
				}
				else
				{
					gl_FragColor = vColor;
				}
			}
		</script>
		<script>
			function Planet(mass, speed, color, pos, radius, orbitFactor)
			{
				this.radius = radius;
				this.mass = mass;
				this.speed = speed;
				this.color = color;
				this.pos = pos;
				this.orbitFactor = orbitFactor;
				this.acc = vec3.create();
				this.update = function(planets)
				{
					var acc = vec3.create();
					for(i in planets)
					{
						if(this.mass != planets[i].mass)
						{
							var dir = vec3.create();
							vec3.subtract(dir, this.pos, planets[i].pos);
							vec3.normalize(dir, dir);
							var change = vec3.create();
							vec3.scale(change, dir, -G * this.mass * planets[i].mass / vec3.squaredDistance(this.pos, planets[i].pos));
							vec3.add(acc, acc, change);
						}
					}
					vec3.scale(acc, acc, 1 / this.mass);
					vec3.add(this.speed, this.speed, acc);
					var temp = vec3.create();
					vec3.scale(temp, this.speed, slowMoFactor);
					vec3.add(this.pos, this.pos, temp);
					this.acc = acc;
				}
				this.initVecBuff = function()
				{
					vertices.push(this.pos[0] / visualFactor, this.pos[1] / visualFactor, this.pos[2] / visualFactor);
					vertices.push(
						(this.pos[0] / visualFactor + this.speed[0] / visualFactor * 1e7),
						(this.pos[1] / visualFactor + this.speed[1] / visualFactor * 1e7),
						(this.pos[2] / visualFactor + this.speed[2] / visualFactor * 1e7)
					);
					colors.push(0, 1, 0, 1);
					colors.push(0, 1, 0, 1);
					indices.push(indices.length, indices.length + 1);
					vertices.push(this.pos[0] / visualFactor, this.pos[1] / visualFactor, this.pos[2] / visualFactor);
					vertices.push(
						(this.pos[0] / visualFactor + this.acc[0] / visualFactor * 1e9),
						(this.pos[1] / visualFactor + this.acc[1] / visualFactor * 1e9),
						(this.pos[2] / visualFactor + this.acc[2] / visualFactor * 1e9)
					);
					colors.push(1, 0, 0, 1);
					colors.push(1, 0, 0, 1);
					indices.push(indices.length, indices.length + 1);
				}
				this.initBuff = function()
				{
					vertices = [];
					indices = [];
					colors = [];
					
					var c = [this.pos[0] / visualFactor, this.pos[1] / visualFactor, this.pos[2] / visualFactor];
					var radius = this.radius;
					vertices.push(
						c[0] + radius,
						c[1] + radius,
						c[2]
					);
					vertices.push(
						c[0] - radius,
						c[1] + radius,
						c[2]
					);
					vertices.push(
						c[0] + radius,
						c[1] - radius,
						c[2]
					);
					vertices.push(
						c[0] - radius,
						c[1] - radius,
						c[2]
					);
					colors.push(this.color[0], this.color[1], this.color[2], 1.0);
					colors.push(this.color[0], this.color[1], this.color[2], 1.0);
					colors.push(this.color[0], this.color[1], this.color[2], 1.0);
					colors.push(this.color[0], this.color[1], this.color[2], 1.0);
					indices.push(0, 1, 2, 3);
					
					glContext.uniform1i(prg.mode, 1);
					glContext.uniform1i(prg.vmode, 1);
					if(planets[i].mass > 1e30)
					{
						glContext.uniform1i(prg.mode, 2);
						glContext.uniform1i(prg.vmode, 2);
					}
						
					glContext.uniform1f(prg.radius, radius);
					glContext.uniform3f(prg.center, c[0], c[1], 0.0);
					
					vertexBuffer = getVertexBufferWithVertices(vertices);
					indexBuffer = getIndexBufferWithIndices(indices);
					colorBuffer = getVertexBufferWithVertices(colors);
					glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
					glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
					glContext.bindBuffer(glContext.ARRAY_BUFFER, colorBuffer);
					glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);
					glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
					glContext.drawElements(glContext.TRIANGLE_STRIP, indices.length, glContext.UNSIGNED_SHORT,0);
				}
				this.initOrbitBuff = function()
				{
					
					vertices = [];
					indices = [];
					colors = [];
					
					vertices.push(this.pos[0] / visualFactor, this.pos[1] / visualFactor, this.pos[2] / visualFactor);
					indices.push(indices.length);
					colors.push(this.color[0], this.color[1], this.color[2], 1.0);
					
					var s = vec3.create();
					var p = vec3.create();
					vec3.copy(s, this.speed);
					vec3.copy(p, this.pos);
					for(var j = 0; j < 50; j++)
					{
						var acc = vec3.create();
						for(i in planets)
						{
							if(this.mass != planets[i].mass)
							{
								var dir = vec3.create();
								vec3.subtract(dir, p, planets[i].pos);
								vec3.normalize(dir, dir);
								var change = vec3.create();
								vec3.scale(change, dir, -G * orbitFactor * this.mass * planets[i].mass / vec3.squaredDistance(p, planets[i].pos));
								vec3.add(acc, acc, change);
							}
						}
						vec3.scale(acc, acc, 1 / this.mass);
						vec3.add(s, s, acc);
						var temp = vec3.create();
						vec3.scale(temp, s, slowMoFactor * orbitFactor);
						vec3.add(p, p, temp);
						vertices.push(p[0] / visualFactor, p[1] / visualFactor, p[2] / visualFactor);
						indices.push(indices.length);
						colors.push(this.color[0], this.color[1], this.color[2], 1.0);
					}
				
					vertexBuffer = getVertexBufferWithVertices(vertices);
					indexBuffer = getIndexBufferWithIndices(indices);
					colorBuffer = getVertexBufferWithVertices(colors);
					
					glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
					glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
					glContext.bindBuffer(glContext.ARRAY_BUFFER, colorBuffer);
					glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);
					glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
					glContext.drawElements(glContext.LINE_STRIP, indices.length, glContext.UNSIGNED_SHORT,0);
				}
			}
			
			var radius = 0.03;
			var slowMoFactor = 1e6;
			var G = 6.67e-11 * slowMoFactor * 10;
			var  visualFactor = 2e13;
			var sol = new Planet(1.98855e30, [0.0, 0.0, 0.0], [1, 1, 1], [0.0, 0.0, 0.0], 0.02, 0);
			var mercury = new Planet(3.3e23, [4.7e4, 0.0, 0.0], [0.4, 0.4, 0.4], [0.0, 5.8e11, 0.0], 0.01, 1.5);
			var venus = new Planet(4.8675e24, [3.5e4, 0.0, 0.0], [0.9, 0.9, 0.7], [0.0, 1.08e12, 0.0], 0.015, 4);
			var earth = new Planet(5.97237e24, [2.978e4, 0.0, 0.0], [0.3, 0.5, 1.0], [0.0, 1.517e12, 0.0], 0.02, 7);
			// var moon = new Planet(7.3477e22, [2.978e4 + 1.022e3, 0.0, 0.0], [0.4, 0.4, 0.4], [0.0, 1.517e12 + 3.84e9, 0.0]);
			var mars = new Planet(6.4171e23, [2.4e4, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 2.27e12, 0.0], 0.01, 12);
			var jupiter = new Planet(1.8986e27, [1.3e4, 0.0, 0.0], [1.0, 0.5, 0.0], [0.0, 7.78e12, 0.0], 0.08, 80);
			var saturn = new Planet(5.6836e26, [9.69e3, 0.0, 0.0], [1.0, 1.0, 0.7], [0.0, 1.353e13, 0.0], 0.06, 200);
			var uranus = new Planet(8.6810e25, [6.8e3, 0.0, 0.0], [0.0, 1.0, 1.0], [0.0, 2.87e13, 0.0], 0.05, 550);
			var neptune = new Planet(1.0243e26, [5.43e3, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 4.498e13, 0.0], 0.05, 1100);
			
			var planets = [sol, mercury, venus, earth, mars, jupiter, saturn, uranus, neptune];
			function updateSystem ()
			{
				for(i in planets)
				{
					planets[i].update(planets);
				}
			}
			function updateBuffSystem ()
			{
				for(i in planets)
				{
					planets[i].initBuff();
				}
			}
			function updateBuffVecSystem ()
			{
				for(i in planets)
				{
					planets[i].initVecBuff();
				}
			}
			function updateBuffOrbitSystem ()
			{
				
				for(i in planets)
				{
					planets[i].initOrbitBuff();
				}
			}
					
			var pause = false;
			var translateZ = -2.0;
			var vertexBuffer = null;
			var indexBuffer = null;
			var colorBuffer = null;
			var indices = [];
			var vertices = [];
			var colors = [];
			var mvMatrix = mat4.create();
			var pMatrix = mat4.create();
			mat4.identity(mvMatrix);
			mat4.identity(pMatrix);
			window.onkeydown = function(e) {
				switch(e.keyCode){
					case 87:
						//w
						translateZ += 0.1;
						break;
					case 83:
						//s
						translateZ -= 0.1;
						break;
					default:
				}
			};
			function initShaderParameters(prg){
				prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
			    glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
			    prg.colorAttribute = glContext.getAttribLocation(prg, "aColor");
			    glContext.enableVertexAttribArray(prg.colorAttribute);
			    prg.pMatrixUniform = glContext.getUniformLocation(prg, 'uPMatrix');
			    prg.mvMatrixUniform = glContext.getUniformLocation(prg, 'uMVMatrix');
				prg.mode = glContext.getUniformLocation(prg, 'mode');
				prg.vmode = glContext.getUniformLocation(prg, 'vmode');
				prg.radius = glContext.getUniformLocation(prg, 'radius');
				prg.center = glContext.getUniformLocation(prg, 'center');
			}
			function initBuffers(){
			}
			function drawVecs()
			{
				vertices = [];
				indices = [];
				colors = [];
				
				updateBuffVecSystem();
				
				vertexBuffer = getVertexBufferWithVertices(vertices);
				indexBuffer = getIndexBufferWithIndices(indices);
				colorBuffer = getVertexBufferWithVertices(colors);
				
				glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
				glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
				glContext.bindBuffer(glContext.ARRAY_BUFFER, colorBuffer);
				glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);
				glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
				glContext.drawElements(glContext.LINES, indices.length, glContext.UNSIGNED_SHORT,0);
			}
			function drawPlanets()
			{
				updateBuffSystem();
			}
			function drawSystem()
			{
				glContext.uniform1i(prg.mode, 0);
				glContext.uniform1i(prg.vmode, 0);
				//drawVecs();
				updateBuffOrbitSystem();
				
				drawPlanets();
			}
			function drawScene(){
				glContext.clearColor(0.0, 0.0, 0.0, 1.0);
				// glContext.enable(glContext.DEPTH_TEST);
				
				glContext.blendFunc(glContext.SRC_ALPHA, glContext.ONE_MINUS_SRC_ALPHA);
				glContext.enable(glContext.BLEND);
				glContext.disable(glContext.DEPTH_TEST);
				
				glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
				
				glContext.viewport(0, 0, c_width, c_height);
				mat4.perspective(pMatrix, degToRad(60.0), c_width / c_height, 0.1, 10000.0);
				translationMat = mat4.create();
				mat4.identity(translationMat);
				mat4.translate(translationMat, translationMat, [0.0, 0.0, translateZ]);
				
				rotateModelViewMatrixUsingQuaternion();
				glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
				mvtMatrix = mat4.create();
				glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mat4.multiply(mvtMatrix, translationMat, mvMatrix));
				rotX = 0;
				rotY = 0;
				
				if (!pause) updateSystem();
				
				drawSystem();
			}
			function initWebGL(){
				glContext = getGLContext('webgl-canvas');
				initProgram();
				initBuffers();
				renderLoop();
			}
			function pauseF()
			{
				pause = !pause;
			}
		</script>
	</head>
	<body onload="initWebGL()">
		<button onclick="pauseF()">Play, Pause</button>
		<br/>
		<canvas id="webgl-canvas" width="750" height="750">
			HTML5 is not supported
		</canvas>
	</body>
	<script src='../js/mouseMotionHandling.js'></script>
</html>
